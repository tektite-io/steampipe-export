package main

import (
	"context"
	encoding_csv "encoding/csv"
	"fmt"
	"os"
	"sort"

	"github.com/golang/protobuf/ptypes"
	{{.Plugin}} "{{.PluginGithubUrl}}/{{.Plugin}}"
	"github.com/turbot/steampipe-plugin-sdk/v5/anywhere"
	"github.com/turbot/steampipe-plugin-sdk/v5/grpc"
	"github.com/turbot/steampipe-plugin-sdk/v5/grpc/proto"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"golang.org/x/exp/slices"
	"google.golang.org/protobuf/reflect/protoreflect"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/turbot/steampipe/pkg/ociinstaller"
)

var pluginServer *grpc.PluginServer
var pluginAlias = "{{.Plugin}}"
var connection = pluginAlias

type displayRowFunc func(row *proto.ExecuteResponse, columns []string)

func main() {
	setupLogger(pluginAlias)
	rootCmd := &cobra.Command{
		Use:   "{{.Plugin}}_dump TABLE_NAME [flags]",
		Short: "Steampipe data Dump",
		Run:   executeCommand,
		Args:  cobra.ExactArgs(1),
	}

	// Define flags
	rootCmd.PersistentFlags().String("config", "", "Config file data")
	rootCmd.PersistentFlags().String("where", "", "where clause data")
	rootCmd.PersistentFlags().StringSlice("select", nil, "Column data to display")
	rootCmd.PersistentFlags().Int("limit", 0, "Limit data")

	viper.BindPFlags(rootCmd.PersistentFlags())

	pluginServer = plugin.Server(&plugin.ServeOpts{
		PluginFunc: {{.Plugin}}.Plugin,
	})

	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

}

func executeCommand(cmd *cobra.Command, args []string) {
	// TODO template

	table := args[0]
	if err := setConnectionConfig(); err != nil {
		// TODO display error
		fmt.Println(err)
		os.Exit((1))
	}

	schema, err := getSchema(table)
	if err != nil {
		// TODO display error
		fmt.Println(err)
		os.Exit((1))
	}

	columns, err := getColumns(schema)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	var qual map[string]*proto.Quals
	if viper.GetString("where") != "" {
		whereFlag := viper.GetString("where")
		qual, err = filterStringToQuals(whereFlag, schema)
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
	}

	executeQuery(table, connection, columns, qual, displayCSVRow)
}

func getColumns(schema *proto.TableSchema) ([]string, error) {
	var columns = viper.GetStringSlice("select")
	if len(columns) != 0 {
		tableColumn := schema.GetColumnNames()
		for _, item := range columns {
			if !slices.Contains(tableColumn, item) {
				return nil, fmt.Errorf("column %s does not exist", item)
			}
		}
	}
	if len(columns) == 0 {
		columns = schema.GetColumnNames()
	}
	sort.Strings(columns)
	return columns, nil
}

func getSchema(table string) (*proto.TableSchema, error) {
	req := &proto.GetSchemaRequest{
		Connection: connection,
	}
	pluginSchema, err := pluginServer.GetSchema(req)
	if err != nil {
		return nil, err
	}
	return pluginSchema.Schema.Schema[table], nil
}

func setConnectionConfig() error {
	pluginName := ociinstaller.NewSteampipeImageRef(pluginAlias).DisplayImageRef()

	connectionConfig := &proto.ConnectionConfig{
		Connection:      connection,
		Plugin:          pluginName,
		PluginShortName: pluginAlias,
		Config:          viper.GetString("config"),
		PluginInstance:  pluginName,
	}

	configs := []*proto.ConnectionConfig{connectionConfig}
	req := &proto.SetAllConnectionConfigsRequest{
		Configs: configs,
	}

	_, err := pluginServer.SetAllConnectionConfigs(req)

	if err != nil {
		return err
	}
	return nil
}

func executeQuery(tableName string, conectionName string, columns []string, qual map[string]*proto.Quals, displayRow displayRowFunc) {
	// construct execute request

	var qualMap = map[string]*proto.Quals{}

	if qual != nil {
		qualMap = qual
	}

	var limit int64 = -1

	if viper.GetInt("limit") != 0 {
		limit = int64(viper.GetInt("limit"))
	}

	queryContext := proto.NewQueryContext(columns, qualMap, limit)
	req := &proto.ExecuteRequest{
		Table:                 tableName,
		QueryContext:          queryContext,
		CallId:                grpc.BuildCallId(),
		Connection:            conectionName,
		TraceContext:          nil,
		ExecuteConnectionData: make(map[string]*proto.ExecuteConnectionData),
	}
	req.ExecuteConnectionData = map[string]*proto.ExecuteConnectionData{
		req.Connection: {
			Limit:        req.QueryContext.Limit,
			CacheEnabled: false,
		},
	}
	ctx := context.Background()
	stream := anywhere.NewLocalPluginStream(ctx)
	pluginServer.CallExecuteAsync(req, stream)
	for {

		response, err := stream.Recv()
		if err != nil {
			fmt.Printf("[ERROR] Error receiving data from the channel: %v", err)
			break
		}
		if response == nil {
			break
		}
		displayRow(response, columns)
	}
}

var rowCount = 0

func displayCSVRow(displayRow *proto.ExecuteResponse, columns []string) {
    row := displayRow.Row
    selectColumns := viper.GetStringSlice("select")

    // Process each column and store values in a map
    res := make(map[string]string, len(row.Columns))
    for columnName, column := range row.Columns {
        var val interface{}
        if bytes := column.GetJsonValue(); bytes != nil {
            val = string(bytes)
        } else if timestamp := column.GetTimestampValue(); timestamp != nil {
            val = ptypes.TimestampString(timestamp)
        } else {
            column.ProtoReflect().Range(func(descriptor protoreflect.FieldDescriptor, v protoreflect.Value) bool {
                if descriptor.JSONName() == "nullValue" {
                    val = nil
                } else {
                    val = v.Interface()
                }
                return false
            })
        }
        res[columnName] = fmt.Sprintf("%v", val)
    }

    // Prepare CSV writer
    writer := encoding_csv.NewWriter(os.Stdout)
    defer writer.Flush()

    // Write headers
    if rowCount == 0 {
        if len(selectColumns) > 0 {
            // Write headers based on selectColumns
            writer.Write(selectColumns)
        } else {
            // Write all headers
            writer.Write(columns)
        }
        writer.Flush()

        if err := writer.Error(); err != nil {
            fmt.Println(err)
        }
    }

    rowCount++

    // Generate row data
    var colVals []string
    if len(selectColumns) > 0 {
        colVals = make([]string, len(selectColumns))
        for i, columnName := range selectColumns {
            colVals[i], _ = res[columnName] // Using _ to ignore whether columnName is present in res
        }
    } else {
        colVals = make([]string, len(columns))
        for i, columnName := range columns {
            colVals[i], _ = res[columnName]
        }
    }

    // Write the row data
    writer.Write(colVals)
    writer.Flush()

    // Handle potential errors from the writer
    if err := writer.Error(); err != nil {
        fmt.Println(err)
    }
}
